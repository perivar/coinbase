import {
  createAsyncThunk,
  createSelector,
  createSlice,
} from '@reduxjs/toolkit';
import cmpData from '../../data/CoinMarketCapData';
import Coin from '../../models/Coin';
import { RootState } from '../store/store';

// https://www.newline.co/@bespoyasov/how-to-use-thunks-with-redux-toolkit-and-typescript--1e65fc64

// This type describes the error object structure:
type FetchTopMoversError = {
  message: string;
};

// The third type-parameter is an object with:
// `{dispatch?, state?, extra?, rejectValue?}`` fields.
//
// `extra` is useful when we need to pass
// some static data to the request function,
// like jwt-token or HTTP-headers.
//
// `rejectValue` is useful when we need to type
// possible errors.
export const fetchTopMovers = createAsyncThunk<
  Coin[],
  void,
  { rejectValue: FetchTopMoversError }
>(
  'topmovers/fetch',
  // The second argument, `thunkApi`, is an object
  // that contains all those fields
  // and the `rejectWithValue` function:
  // or use the deconstructed { rejectWithValue } value
  async (_, { rejectWithValue }) => {
    let coinData: Coin[] = [];

    try {
      // Get all coins available on Coinbase
      const cbResponse = await fetch('https://api.pro.coinbase.com/products');

      // Check if status is not okay:
      if (cbResponse.status !== 200) {
        // Return the error message:
        return rejectWithValue({
          message: 'Failed to fetch products.',
        });
      }

      const cbResponseData = await cbResponse.json();

      let availableCoins: string[] = [];

      interface CBRequiredData {
        quote_currency: string;
        base_currency: string;
      }
      const filteredData = cbResponseData.filter(
        (coin: CBRequiredData) => coin.quote_currency === 'USD'
      );

      filteredData.forEach((coin: CBRequiredData) => {
        availableCoins.push(coin.base_currency);
      });

      // Get coin prices from cryptocompare API
      const cryptoResponse = await fetch(
        `https://min-api.cryptocompare.com/data/pricemultifull?tsyms=USD&relaxedValidation=true&fsyms=${availableCoins.join()}`
      );

      // Check if status is not okay:
      if (cryptoResponse.status !== 200) {
        // Return the error message:
        return rejectWithValue({
          message: 'Failed to fetch prices.',
        });
      }

      const cryptoResponseData = await cryptoResponse.json();

      let dataAsArray = Object.values(cryptoResponseData.RAW);

      // Sort by percent change 24hrs (descending)
      dataAsArray.sort((a: any, b: any) =>
        Math.abs(a.USD.CHANGEPCT24HOUR) < Math.abs(b.USD.CHANGEPCT24HOUR)
          ? 1
          : -1
      );

      // Get a maximum of 6 top movers which are available on Coinbase
      for (const data of dataAsArray) {
        const cryptoData: any = data;
        // Get ID and name from coin market cap data
        const cmpDetails = cmpData.data.find(
          cmpCoin => cryptoData.USD.FROMSYMBOL === cmpCoin.symbol
        );
        const coinID = cmpDetails?.id ?? 0;
        const coinName = cmpDetails?.name ?? 'Unknown';

        coinData.push(
          new Coin(
            coinID,
            coinName,
            cryptoData.USD.FROMSYMBOL,
            cryptoData.USD.PRICE,
            cryptoData.USD.CHANGEPCT24HOUR
          )
        );
        if (coinData.length === 6) {
          break;
        }
      }
    } catch (err) {
      // You can choose to use the message attached to err or write a custom error
      // Return the error message:
      return rejectWithValue({
        message: 'Failed to fetch top movers: ' + err,
      });
    }

    return coinData;
  }
);

// here we are typing the types for the state
type TopMoversState = {
  loading: boolean;

  // `error` will contain an error message.
  error: string | null;
  coinData: Coin[];
};

const initialState: TopMoversState = {
  coinData: [],
  error: null,
  loading: false,
};

export const topMoverSlice = createSlice({
  name: 'topmovers',
  initialState,
  reducers: {
    // leave this empty here
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
  // Since this is an API call we have 3 possible outcomes: pending, fulfilled and rejected. We have made allocations for all 3 outcomes.
  // Doing this is good practice as we can tap into the status of the API call and give our users an idea of what's happening in the background.
  extraReducers: builder => {
    // When we send a request,
    // `fetchTopMovers.pending` is being fired:
    builder.addCase(fetchTopMovers.pending, state => {
      // At that moment,
      // we change loading to true
      // and clear all the previous errors:
      state.loading = true;
      state.error = null;
    });

    // When a server responses with the data,
    // `fetchTopMovers.fulfilled` is fired:
    builder.addCase(fetchTopMovers.fulfilled, (state, { payload }) => {
      // We add all the new news into the state
      // and change `loading` back to `false`:
      state.coinData = payload;
      state.loading = false;
    });

    // When a server responses with an error:
    builder.addCase(fetchTopMovers.rejected, (state, { payload }) => {
      // We show the error message
      // and change `loading` back to `false`:
      if (payload) state.error = payload.message;
      state.loading = false;
    });
  },
});

export const selectTopMovers = (state: RootState) => state.topmovers;

export const topMoversSelector = createSelector(
  selectTopMovers,
  state => state
);

export default topMoverSlice.reducer;
